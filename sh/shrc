# If not running interactively, don't do anything
[[ $- = *i* ]] || return 0

_prompt_command () {
  local shell="$1"
  local current_dir="$(dirname "$(dirs)")"

  # Set terminal title
  echo -en "\033]0;$shell - $current_dir\a"

  # Print last command error code
  [[ "$2" = 0 ]] || echo "[1;31m!$2[0m"
}

# Detailed prompt
p () {
  local current_dir="[1;34m$(dirs)[0m"

  # Git info only if in repo
  if $(git rev-parse --is-inside-work-tree &> /dev/null); then
    local staged modified untracked conflicted line
    # Parse status
    while read -r line; do
      case "$line" in
        '# branch.head '*)
          local branch="${line#\# branch.head }"
          [[ "$branch" != "(detached)" ]] ||
            branch="$( \
              git describe --tags --exact-match 2> /dev/null ||
              git rev-parse --short HEAD
            )"
          ;;
        '# branch.ab '*)
          local ahead behind
          read -r _ _ ahead behind <<< "$line"
          ahead=${ahead#+}
          behind=${behind#-}
          ;;
        '# branch.upstream '*)
          local upstream="${line#\# branch.upstream }"
          git rev-parse --abbrev-ref "$upstream" &> /dev/null ||
            local upstream_gone=true
          ;;
        '1 '*)
          local sc
          read -r _ sc _ <<< "$line"
          case "$sc" in
            U*) let conflicted++ ;;
            \?*) let untracked ;;
            *M) let modified++ ;;
            *) let staged++ ;;
          esac
          unset sc
          ;;
        '2 '*) let staged++ ;;
        '? '*) let untracked++ ;;
      esac
    done < \
      <(git status --porcelain=v2 --branch 2> /dev/null)

    # Check for stashed changes
    ! git rev-parse --verify refs/stash &> /dev/null ||
      local stashed=true

    # Display output
    local git_status="$branch"
    # Remote status
    if [[ "$ahead" != 0 && "$behind" != 0 ]]; then
      git_status="$git_status $behind<->$ahead"
    else
      [[ "$ahead" = 0 ]] || git_status="$git_status ->$ahead"
      [[ "$behind" = 0 ]] || git_status="$git_status <-$behind"
    fi
    [[ "${upstream_gone:-false}" = false ]] || git_status="$git_status <~"
    # File status
    [[ -z "$staged" ]] || git_status="$git_status +$staged"
    [[ -z "$modified" ]] || git_status="$git_status !$modified"
    [[ -z "$untracked" ]] || git_status="$git_status ?$untracked"
    [[ -z "$conflicted" ]] || git_status="$git_status ~$conflicted"
    [[ "${stashed:-false}" = false ]] || git_status="$git_status \$"
  fi

  # Overwrite current prompt
  echo "$(tput up)$current_dir ${git_status+on} $git_status"
}

# Simple prompt
export PS1='$ '

# Vi keybindings
set -o vi
# No ESC timeout delay for vi keybindings
KEYTIMEOUT=1

# Load custom aliases
[[ ! -f ~/.config/sh/aliases ]] || . ~/.config/sh/aliases
